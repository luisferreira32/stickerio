/*
Stickerio API

MMO RTS Stickerio game on an API.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiV1CitiesCityidBuildingqitemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
	lastid *string
	pagesize *int32
}

func (r ApiV1CitiesCityidBuildingqitemsGetRequest) Lastid(lastid string) ApiV1CitiesCityidBuildingqitemsGetRequest {
	r.lastid = &lastid
	return r
}

func (r ApiV1CitiesCityidBuildingqitemsGetRequest) Pagesize(pagesize int32) ApiV1CitiesCityidBuildingqitemsGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1CitiesCityidBuildingqitemsGetRequest) Execute() ([]V1BuildingQueueItem, *http.Response, error) {
	return r.ApiService.V1CitiesCityidBuildingqitemsGetExecute(r)
}

/*
V1CitiesCityidBuildingqitemsGet List building queue items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidBuildingqitemsGetRequest
*/
func (a *DefaultAPIService) V1CitiesCityidBuildingqitemsGet(ctx context.Context, cityid string) ApiV1CitiesCityidBuildingqitemsGetRequest {
	return ApiV1CitiesCityidBuildingqitemsGetRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
//  @return []V1BuildingQueueItem
func (a *DefaultAPIService) V1CitiesCityidBuildingqitemsGetExecute(r ApiV1CitiesCityidBuildingqitemsGetRequest) ([]V1BuildingQueueItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1BuildingQueueItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidBuildingqitemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/buildingqitems"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastid", r.lastid, "")
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidBuildingqitemsItemidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
	itemid string
}

func (r ApiV1CitiesCityidBuildingqitemsItemidGetRequest) Execute() (*V1BuildingQueueItem, *http.Response, error) {
	return r.ApiService.V1CitiesCityidBuildingqitemsItemidGetExecute(r)
}

/*
V1CitiesCityidBuildingqitemsItemidGet Get a building queue item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @param itemid
 @return ApiV1CitiesCityidBuildingqitemsItemidGetRequest
*/
func (a *DefaultAPIService) V1CitiesCityidBuildingqitemsItemidGet(ctx context.Context, cityid string, itemid string) ApiV1CitiesCityidBuildingqitemsItemidGetRequest {
	return ApiV1CitiesCityidBuildingqitemsItemidGetRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
		itemid: itemid,
	}
}

// Execute executes the request
//  @return V1BuildingQueueItem
func (a *DefaultAPIService) V1CitiesCityidBuildingqitemsItemidGetExecute(r ApiV1CitiesCityidBuildingqitemsItemidGetRequest) (*V1BuildingQueueItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1BuildingQueueItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidBuildingqitemsItemidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/buildingqitems/{itemid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemid"+"}", url.PathEscape(parameterValueToString(r.itemid, "itemid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidBuildingqitemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
	v1BuildingQueueItem *V1BuildingQueueItem
}

func (r ApiV1CitiesCityidBuildingqitemsPostRequest) V1BuildingQueueItem(v1BuildingQueueItem V1BuildingQueueItem) ApiV1CitiesCityidBuildingqitemsPostRequest {
	r.v1BuildingQueueItem = &v1BuildingQueueItem
	return r
}

func (r ApiV1CitiesCityidBuildingqitemsPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.V1CitiesCityidBuildingqitemsPostExecute(r)
}

/*
V1CitiesCityidBuildingqitemsPost Add a queue item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidBuildingqitemsPostRequest
*/
func (a *DefaultAPIService) V1CitiesCityidBuildingqitemsPost(ctx context.Context, cityid string) ApiV1CitiesCityidBuildingqitemsPostRequest {
	return ApiV1CitiesCityidBuildingqitemsPostRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultAPIService) V1CitiesCityidBuildingqitemsPostExecute(r ApiV1CitiesCityidBuildingqitemsPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidBuildingqitemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/buildingqitems"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1BuildingQueueItem == nil {
		return localVarReturnValue, nil, reportError("v1BuildingQueueItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1BuildingQueueItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidDeleteRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
}

func (r ApiV1CitiesCityidDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.V1CitiesCityidDeleteExecute(r)
}

/*
V1CitiesCityidDelete Delete a city.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidDeleteRequest
*/
func (a *DefaultAPIService) V1CitiesCityidDelete(ctx context.Context, cityid string) ApiV1CitiesCityidDeleteRequest {
	return ApiV1CitiesCityidDeleteRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
func (a *DefaultAPIService) V1CitiesCityidDeleteExecute(r ApiV1CitiesCityidDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiV1CitiesCityidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
}

func (r ApiV1CitiesCityidGetRequest) Execute() (*V1City, *http.Response, error) {
	return r.ApiService.V1CitiesCityidGetExecute(r)
}

/*
V1CitiesCityidGet Get a city complete state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidGetRequest
*/
func (a *DefaultAPIService) V1CitiesCityidGet(ctx context.Context, cityid string) ApiV1CitiesCityidGetRequest {
	return ApiV1CitiesCityidGetRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
//  @return V1City
func (a *DefaultAPIService) V1CitiesCityidGetExecute(r ApiV1CitiesCityidGetRequest) (*V1City, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1City
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidInfoGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
}

func (r ApiV1CitiesCityidInfoGetRequest) Execute() (*V1CityInfo, *http.Response, error) {
	return r.ApiService.V1CitiesCityidInfoGetExecute(r)
}

/*
V1CitiesCityidInfoGet Get a city info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidInfoGetRequest
*/
func (a *DefaultAPIService) V1CitiesCityidInfoGet(ctx context.Context, cityid string) ApiV1CitiesCityidInfoGetRequest {
	return ApiV1CitiesCityidInfoGetRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
//  @return V1CityInfo
func (a *DefaultAPIService) V1CitiesCityidInfoGetExecute(r ApiV1CitiesCityidInfoGetRequest) (*V1CityInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1CityInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidInfoGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/info"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidUnitqitemsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
	lastid *string
	pagesize *int32
}

func (r ApiV1CitiesCityidUnitqitemsGetRequest) Lastid(lastid string) ApiV1CitiesCityidUnitqitemsGetRequest {
	r.lastid = &lastid
	return r
}

func (r ApiV1CitiesCityidUnitqitemsGetRequest) Pagesize(pagesize int32) ApiV1CitiesCityidUnitqitemsGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1CitiesCityidUnitqitemsGetRequest) Execute() ([]V1UnitQueueItem, *http.Response, error) {
	return r.ApiService.V1CitiesCityidUnitqitemsGetExecute(r)
}

/*
V1CitiesCityidUnitqitemsGet List unit queue items.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidUnitqitemsGetRequest
*/
func (a *DefaultAPIService) V1CitiesCityidUnitqitemsGet(ctx context.Context, cityid string) ApiV1CitiesCityidUnitqitemsGetRequest {
	return ApiV1CitiesCityidUnitqitemsGetRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
//  @return []V1UnitQueueItem
func (a *DefaultAPIService) V1CitiesCityidUnitqitemsGetExecute(r ApiV1CitiesCityidUnitqitemsGetRequest) ([]V1UnitQueueItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1UnitQueueItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidUnitqitemsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/unitqitems"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastid", r.lastid, "")
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidUnitqitemsItemidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
	itemid string
}

func (r ApiV1CitiesCityidUnitqitemsItemidGetRequest) Execute() (*V1UnitQueueItem, *http.Response, error) {
	return r.ApiService.V1CitiesCityidUnitqitemsItemidGetExecute(r)
}

/*
V1CitiesCityidUnitqitemsItemidGet Get a unit queue item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @param itemid
 @return ApiV1CitiesCityidUnitqitemsItemidGetRequest
*/
func (a *DefaultAPIService) V1CitiesCityidUnitqitemsItemidGet(ctx context.Context, cityid string, itemid string) ApiV1CitiesCityidUnitqitemsItemidGetRequest {
	return ApiV1CitiesCityidUnitqitemsItemidGetRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
		itemid: itemid,
	}
}

// Execute executes the request
//  @return V1UnitQueueItem
func (a *DefaultAPIService) V1CitiesCityidUnitqitemsItemidGetExecute(r ApiV1CitiesCityidUnitqitemsItemidGetRequest) (*V1UnitQueueItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1UnitQueueItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidUnitqitemsItemidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/unitqitems/{itemid}"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemid"+"}", url.PathEscape(parameterValueToString(r.itemid, "itemid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesCityidUnitqitemsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	cityid string
	v1UnitQueueItem *V1UnitQueueItem
}

func (r ApiV1CitiesCityidUnitqitemsPostRequest) V1UnitQueueItem(v1UnitQueueItem V1UnitQueueItem) ApiV1CitiesCityidUnitqitemsPostRequest {
	r.v1UnitQueueItem = &v1UnitQueueItem
	return r
}

func (r ApiV1CitiesCityidUnitqitemsPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.V1CitiesCityidUnitqitemsPostExecute(r)
}

/*
V1CitiesCityidUnitqitemsPost Add a queue item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param cityid
 @return ApiV1CitiesCityidUnitqitemsPostRequest
*/
func (a *DefaultAPIService) V1CitiesCityidUnitqitemsPost(ctx context.Context, cityid string) ApiV1CitiesCityidUnitqitemsPostRequest {
	return ApiV1CitiesCityidUnitqitemsPostRequest{
		ApiService: a,
		ctx: ctx,
		cityid: cityid,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultAPIService) V1CitiesCityidUnitqitemsPostExecute(r ApiV1CitiesCityidUnitqitemsPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesCityidUnitqitemsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities/{cityid}/unitqitems"
	localVarPath = strings.Replace(localVarPath, "{"+"cityid"+"}", url.PathEscape(parameterValueToString(r.cityid, "cityid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1UnitQueueItem == nil {
		return localVarReturnValue, nil, reportError("v1UnitQueueItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1UnitQueueItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	lastid *string
	pagesize *int32
	playerid *string
	locationbounds *[]int32
}

func (r ApiV1CitiesGetRequest) Lastid(lastid string) ApiV1CitiesGetRequest {
	r.lastid = &lastid
	return r
}

func (r ApiV1CitiesGetRequest) Pagesize(pagesize int32) ApiV1CitiesGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1CitiesGetRequest) Playerid(playerid string) ApiV1CitiesGetRequest {
	r.playerid = &playerid
	return r
}

func (r ApiV1CitiesGetRequest) Locationbounds(locationbounds []int32) ApiV1CitiesGetRequest {
	r.locationbounds = &locationbounds
	return r
}

func (r ApiV1CitiesGetRequest) Execute() ([]V1CityInfo, *http.Response, error) {
	return r.ApiService.V1CitiesGetExecute(r)
}

/*
V1CitiesGet List city infos with the given filters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1CitiesGetRequest
*/
func (a *DefaultAPIService) V1CitiesGet(ctx context.Context) ApiV1CitiesGetRequest {
	return ApiV1CitiesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1CityInfo
func (a *DefaultAPIService) V1CitiesGetExecute(r ApiV1CitiesGetRequest) ([]V1CityInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1CityInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastid", r.lastid, "")
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	}
	if r.playerid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playerid", r.playerid, "")
	}
	if r.locationbounds != nil {
		t := *r.locationbounds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locationbounds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locationbounds", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1CitiesPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1CityInfo *V1CityInfo
}

func (r ApiV1CitiesPostRequest) V1CityInfo(v1CityInfo V1CityInfo) ApiV1CitiesPostRequest {
	r.v1CityInfo = &v1CityInfo
	return r
}

func (r ApiV1CitiesPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.V1CitiesPostExecute(r)
}

/*
V1CitiesPost Create a city.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1CitiesPostRequest
*/
func (a *DefaultAPIService) V1CitiesPost(ctx context.Context) ApiV1CitiesPostRequest {
	return ApiV1CitiesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultAPIService) V1CitiesPostExecute(r ApiV1CitiesPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1CitiesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/cities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1CityInfo == nil {
		return localVarReturnValue, nil, reportError("v1CityInfo is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1CityInfo
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MovementsGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	lastid *string
	pagesize *int32
	originid *string
	destinationid *string
}

func (r ApiV1MovementsGetRequest) Lastid(lastid string) ApiV1MovementsGetRequest {
	r.lastid = &lastid
	return r
}

func (r ApiV1MovementsGetRequest) Pagesize(pagesize int32) ApiV1MovementsGetRequest {
	r.pagesize = &pagesize
	return r
}

func (r ApiV1MovementsGetRequest) Originid(originid string) ApiV1MovementsGetRequest {
	r.originid = &originid
	return r
}

func (r ApiV1MovementsGetRequest) Destinationid(destinationid string) ApiV1MovementsGetRequest {
	r.destinationid = &destinationid
	return r
}

func (r ApiV1MovementsGetRequest) Execute() ([]V1Movement, *http.Response, error) {
	return r.ApiService.V1MovementsGetExecute(r)
}

/*
V1MovementsGet List the movements happening for the player.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MovementsGetRequest
*/
func (a *DefaultAPIService) V1MovementsGet(ctx context.Context) ApiV1MovementsGetRequest {
	return ApiV1MovementsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []V1Movement
func (a *DefaultAPIService) V1MovementsGetExecute(r ApiV1MovementsGetRequest) ([]V1Movement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []V1Movement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MovementsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/movements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.lastid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lastid", r.lastid, "")
	}
	if r.pagesize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pagesize", r.pagesize, "")
	}
	if r.originid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originid", r.originid, "")
	}
	if r.destinationid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationid", r.destinationid, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MovementsMovementidGetRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	movementid string
}

func (r ApiV1MovementsMovementidGetRequest) Execute() (*V1Movement, *http.Response, error) {
	return r.ApiService.V1MovementsMovementidGetExecute(r)
}

/*
V1MovementsMovementidGet Get a movement for the player.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param movementid
 @return ApiV1MovementsMovementidGetRequest
*/
func (a *DefaultAPIService) V1MovementsMovementidGet(ctx context.Context, movementid string) ApiV1MovementsMovementidGetRequest {
	return ApiV1MovementsMovementidGetRequest{
		ApiService: a,
		ctx: ctx,
		movementid: movementid,
	}
}

// Execute executes the request
//  @return V1Movement
func (a *DefaultAPIService) V1MovementsMovementidGetExecute(r ApiV1MovementsMovementidGetRequest) (*V1Movement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V1Movement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MovementsMovementidGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/movements/{movementid}"
	localVarPath = strings.Replace(localVarPath, "{"+"movementid"+"}", url.PathEscape(parameterValueToString(r.movementid, "movementid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV1MovementsPostRequest struct {
	ctx context.Context
	ApiService *DefaultAPIService
	v1Movement *V1Movement
}

func (r ApiV1MovementsPostRequest) V1Movement(v1Movement V1Movement) ApiV1MovementsPostRequest {
	r.v1Movement = &v1Movement
	return r
}

func (r ApiV1MovementsPostRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.V1MovementsPostExecute(r)
}

/*
V1MovementsPost Start a movement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV1MovementsPostRequest
*/
func (a *DefaultAPIService) V1MovementsPost(ctx context.Context) ApiV1MovementsPostRequest {
	return ApiV1MovementsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *DefaultAPIService) V1MovementsPostExecute(r ApiV1MovementsPostRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.V1MovementsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/movements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v1Movement == nil {
		return localVarReturnValue, nil, reportError("v1Movement is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v1Movement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
